#!/usr/bin/env ruby
# coding: utf-8

require 'optparse'
require 'pp'
require 'pathname'
require 'open3'
require 'yaml'

ARGV << '--help' if ARGV.empty?

args =  OptionParser.new.instance_eval {
  self.banner        = 'Usage: blog [options]'
  self.summary_width = 14

  %w[
    -i :generate\ index.html
    -g\ <file\ path> :generate\ page\ under\ repos\ into\ articles
    -r\ <revision> :specify\ gitrevisions\ (default:\ master)
    -s\ [root_path] :launch\ web\ server
    -p\ <ad:port> :bind\ address\ and\ port\ for\ webserver
    -w\ <ad:port> :bind\ address\ and\ port\ for\ websocket
    -c\ <file\ path> :check\ path
    -f\ <cfg.yaml> :fetch\ repositories
  ].each_slice(2){|ar| on(*ar)}

  parse(ARGV)
}

opt = ARGV.getopts("ig:r:s:p:c:w:f:")

require_relative "../conf/conf"

case
  when opt[?i] then
    require_relative "lib/fetch_repos"
    require_relative 'lib/utils/util'
    require_relative "lib/generate_index"

    cache = Blog::Fetch.fetch_repos(YAML.load_file(opt[?f]))
    Blog::Fetch.cache = Blog::Fetch.index_model(cache)

    Asciidoctor.convert_file(
      PROJ_ROOT + "/templ/index.adoc", 
      safe:       :unsafe, 
      base_dir:   (PROJ_ROOT + "/templ"), 
      to_dir:     "../articles",
      attributes: { 
        'docinfodir' => (PROJ_ROOT + "/templ/common"), 
        'docinfo'    => "shared"
      }
    )

  when path = opt[?c] then
    require_relative "lib/generate_page"
    exit 1 unless valid_path?(path, opt[?r])

  when path = opt[?g] then
    require_relative "lib/generate_page"
    exit 1 unless ret = valid_path?(path, opt[?r])
    exit 1 unless generate_page(*ret, true)

  when opt[?s] then
    require_relative "lib/server"
    launch(opt)

  when opt[?w] then
    require_relative 'lib/websocket'
    wsonly(opt)

  when y = opt[?f] then
    require_relative "lib/fetch_repos"
    require_relative 'lib/utils/util'
    Blog::Fetch.fetch_repos(YAML.load_file(y))
    #pp Blog::Fetch.index_model(cache)
end
